#!/usr/bin/env python3
# /// script
# dependencies = [
#   "internetarchive",
#   "requests",
# ]
# ///

"""
This script fills out the metadata for an Internet Archive item that contains
a Certificate Transparency log archived using photocamera-archiver.

Authentication is automatically loaded from the ia CLI configuration file.
Make sure you've configured the ia CLI first with: ia configure.

Run the script with: uv run --script cmd/photocamera-archiver/ia-metadata.py <IDENTIFIER>
"""

import sys
import requests
from internetarchive import get_item, modify_metadata


DESCRIPTION = """<p>This is an archive of a Certificate Transparency log, stored in the <a href="https://c2sp.org/static-ct-api" rel="ugc nofollow">c2sp.org/static-ct-api@v1.0.0</a> format, although if this log was originally served through RFC 6962 APIs, leaves might miss the LeafIndex extension.</p>

<p>The log is split over multiple zip files. Archive <code>&lt;N&gt;.zip</code> contains the tiles at levels -1 (the data entries), 0, 1, and 2 belonging to subtree</p>

<pre>[ 256×256×256×N, min(256×256×256×(N+1), TreeSize) )</pre>

<p>In other words, each zip file contains one level 2 tile, and all those below it.</p>

<p>Every zip file also contains the following files:</p>

<ul>
    <li><code>README.txt</code> — this file</li>

    <li><code>checkpoint</code> — a Signed Tree Head in <a href="https://c2sp.org/tlog-checkpoint" rel="ugc nofollow">c2sp.org/tlog-checkpoint</a> format</li>

    <li><code>log.v3.json</code> — a JSON specification of the log, including its log ID, public key, and original URL</li>

    <li><code>issuer/*</code> — the X.509 chain issuers for the whole log</li>

    <li><code>tile/{3,4}/*</code> — higher-level tiles, including the hash of other level 2 tiles not included in this archive</li>

    <li><code>tile/{0,1,2}/*.p/*</code> — partial tiles on the right edge of the tree, if any, necessary to compute the tree head</li>
</ul>

<p>This archive was generated by <a href="https://geomys.org/ct-archive/cmd/photocamera-archiver" rel="ugc nofollow">geomys.org/ct-archive/cmd/photocamera-archiver</a>.</p>"""


def main():
    if len(sys.argv) != 2:
        print("Usage: ia-metadata.py <IDENTIFIER>", file=sys.stderr)
        sys.exit(1)

    identifier = sys.argv[1]

    print(f"Fetching current metadata for item {identifier}...", file=sys.stderr)
    item = get_item(identifier)
    metadata = item.metadata

    print("Fetching checkpoint and log info...", file=sys.stderr)
    checkpoint_url = f"https://archive.org/download/{identifier}/000.zip/checkpoint"
    log_info_url = f"https://archive.org/download/{identifier}/000.zip/log.v3.json"

    checkpoint_resp = requests.get(checkpoint_url)
    checkpoint_resp.raise_for_status()
    checkpoint = checkpoint_resp.text

    log_info_resp = requests.get(log_info_url)
    log_info_resp.raise_for_status()
    log_info = log_info_resp.json()

    # Validate collection and mediatype
    collection = metadata.get('collection', '')
    if collection != 'opensource_media':
        print(f"Warning: collection is '{collection}', expected 'opensource_media'", file=sys.stderr)
        print("  See https://help.archive.org/help/how-to-move-an-item-to-another-collection/", file=sys.stderr)

    mediatype = metadata.get('mediatype', '')
    if mediatype != 'data':
        print(f"Warning: mediatype is '{mediatype}', expected 'data'", file=sys.stderr)

    # Extract log size from checkpoint (second line)
    log_size = checkpoint.split('\n')[1].strip()

    # Prepare new metadata
    new_metadata = {
        'title': log_info['description'],
        'description': DESCRIPTION,
        'subject': 'certificate transparency log',
        'ctlogid': log_info['log_id'],
        'ctlogsize': log_size,
    }

    if 'url' in log_info:
        new_metadata['cturl'] = log_info['url']
    elif 'submission_url' in log_info:
        new_metadata['ctsubmissionurl'] = log_info['submission_url']
        new_metadata['ctmonitoringurl'] = log_info['monitoring_url']

    if 'temporal_interval' in log_info:
        new_metadata['ctintervalstart'] = log_info['temporal_interval']['start_inclusive']
        new_metadata['ctintervalend'] = log_info['temporal_interval']['end_exclusive']

    print("New metadata to be set:", file=sys.stderr)
    print(f"  Title: {new_metadata['title']}", file=sys.stderr)
    print("  Description: (omitted for brevity)", file=sys.stderr)
    print(f"  Subject: {new_metadata['subject']}", file=sys.stderr)
    print(f"  CT Log ID: {new_metadata['ctlogid']}", file=sys.stderr)
    print(f"  CT URL: {new_metadata['cturl']}", file=sys.stderr)
    if 'ctintervalstart' in new_metadata and 'ctintervalend' in new_metadata:
        print(f"  CT Interval Start: {new_metadata['ctintervalstart']}", file=sys.stderr)
        print(f"  CT Interval End: {new_metadata['ctintervalend']}", file=sys.stderr)
    print(f"  CT Log Size: {new_metadata['ctlogsize']}", file=sys.stderr)

    print(f"Updating metadata for item {identifier}...", file=sys.stderr)
    response = modify_metadata(identifier, metadata=new_metadata)

    if response.status_code == 200:
        print("Metadata updated successfully!", file=sys.stderr)
    else:
        print(f"Error updating metadata: {response.status_code}", file=sys.stderr)
        print(response.text, file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
